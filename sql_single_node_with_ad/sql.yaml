# changes
# s3 bucket changes
# parameters for FSx ONTAP
# removed windows FSx and added parts for FSx ONTAP

---
AWSTemplateFormatVersion: '2010-09-09'
Description: This workload template deploys a SqlFSx instance in an existing VPC. **IMPORTANT**
  This template creates EC2 instances and related resources. You will be billed for
  the AWS resources used if you create a stack from this template. (qs-1rqmju6ap)
Metadata:
  cfn-lint:
    config:
      ignore_checks:
        - W9006
        - E9101
  QuickStartDocumentation:
    EntrypointName: "Parameters for deploying into an existing VPC with AWS Managed Microsoft AD"
    Order: "2"
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Network configuration
      Parameters:
      - VPCID
      - PrivateSubnet1ID
      - PrivateSubnet2ID
      - RouteTableIDs
      - VPCcidr
    - Label:
        default: Microsoft Active Directory configuration
      Parameters:
      - DomainDNSName
      - DomainNetBIOSName
      - DomainAdminUser
      - DomainAdminPassword
      - DomainMemberSGID
      - ADDnsIpAddresses
      - DirectoryId
    - Label:
        default: Amazon EC2 configuration
      Parameters:
      - SqlFSxServerNetBIOSName1
      - KeyPairName
      - WindowsVersion
      - WorkloadInstanceType
    - Label:
        default: Amazon FSx Windows file-share configuration
      Parameters:
      - FileShareVolumeSize
      - FileShareThroughputCapacity
      - FileShareStorageCapacity
      - FSxAdminPassword
    - Label:
        default: Microsoft SQL Server FCI configurations
      Parameters:
      - MSSQLMediaBucketName
      - MSSQLMediaPathKey
      - SQLAdminAccounts
    - Label:
        default: AWS Quick Start configuration
      Parameters:
      - QSS3BucketName
      - QSS3BucketRegion
      - QSS3KeyPrefix
    ParameterLabels:
      KeyPairName:
        default: SSH key name
      PrivateSubnet1ID:
        default: Private subnet 1 ID
      PrivateSubnet2ID:
        default: Private subnet 2 ID
      RouteTableIDs:
        default: Explicit route table IDs if any
      VPCcidr:
        default: VPC CIDR
      QSS3BucketName:
        default: Quick Start S3 bucket name
      QSS3BucketRegion:
        default: Quick Start S3 bucket Region
      QSS3KeyPrefix:
        default: Quick Start S3 key prefix
      VPCID:
        default: VPC ID
      WorkloadInstanceType:
        default: Workload servers instance type
      DomainAdminPassword:
        default: Domain administrator password
      DomainAdminUser:
        default: Domain administrator user name
      DomainDNSName:
        default: Domain DNS name
      DomainMemberSGID:
        default: Security group ID for Active Directory domain members
      DomainNetBIOSName:
        default: Domain NetBIOS name
      MSSQLMediaBucketName:
        default: S3 bucket for SQL media
      MSSQLMediaPathKey:
        default: S3 key for SQL media path
      SQLAdminAccounts:
        default: SQL administrator account or accounts
      ADDnsIpAddresses:
        default: Active Directory DNS IP addresses
      DirectoryId:
        default: ID of the AWS Directory Service directory
      SqlFSxServerNetBIOSName1:
        default: Server1 NetBIOS name
      WindowsVersion:
        default: Windows version
      FileShareVolumeSize:
        default: File-share volume size
      FileShareThroughputCapacity:
        default: File-share throughput capacity
      FileShareStorageCapacity:
        default: File-share storage capacity
      FSxAdminPassword:
        default: FSx admin password
Parameters:
  KeyPairName:
    Description: Name of an existing EC2 key pair. All instances will launch with
      this key pair.
    Type: AWS::EC2::KeyPair::KeyName
  FileShareVolumeSize:
    Default: 40960
    Description: Capacity (MB) of the volume used to store SQL Server files. Minimum value is 0 and maximum 2147483647.
    Type: Number
    MinValue: 0
    MaxValue: 2147483647
  FileShareThroughputCapacity:
    Default: 128
    Description: File-share throughput capacity (MB/s) in 2 to the nth power increments, where 3 ? n ? 11, i.e. between 2^3 and 2^11.
    Type: Number
    AllowedValues:
      - 128
      - 256
      - 512
      - 1024
      - 2048
      - 4096
  FileShareStorageCapacity:
    Default: 1024
    Description: File-share storage capacity (GiB).
    Type: Number
    MinValue: 1024
    MaxValue: 102400
  FSxAdminPassword:
    Description: Password for the fsxadmin account.
    MaxLength: '32'
    MinLength: '0'
    NoEcho: 'true'
    Type: String
  PrivateSubnet1ID:
    Description: ID of private subnet 1 in Availability Zone 1 for the workload (e.g.,
      subnet-a0246dcd).
    Type: AWS::EC2::Subnet::Id
  PrivateSubnet2ID:
    Description: ID of private subnet 2 in Availability Zone 2 for the workload (e.g.,
      subnet-a0246dcd).
    Type: AWS::EC2::Subnet::Id
  RouteTableIDs:
    Description: Explicit route table IDs if any. enter values separated by comma ',' (e,g, rtb-001,rtb-002)
    Type: String
    Default: ""
  QSS3BucketName:
    AllowedPattern: "^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$"
    ConstraintDescription: The Quick Start bucket name can include numbers, lowercase
      letters, uppercase letters, and hyphens (-). It cannot start or end with a
      hyphen (-).
    # Default: aws-quickstart
    Default: vedant-sql
    Description: Name of the S3 bucket for your copy of the Quick Start assets.
      Keep the default name unless you are customizing the template.
      Changing the name updates code references to point to a new Quick
      Start location. This name can include numbers, lowercase letters,
      uppercase letters, and hyphens, but do not start or end with a hyphen (-).
      See https://aws-quickstart.github.io/option1.html.
    Type: String
  QSS3BucketRegion:
    Default: us-east-1
    Description: AWS Region where the Quick Start S3 bucket (QSS3BucketName) is hosted. Keep the default Region unless you are customizing the template. Changing this Region updates code references to point to a new Quick Start location.  When using your own bucket, specify the Region. See https://aws-quickstart.github.io/option1.html.
    Type: String
  QSS3KeyPrefix:
    AllowedPattern: "^[0-9a-zA-Z-/]*$"
    ConstraintDescription: The Quick Start S3 key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slashes (/). The prefix should
      end with a forward slash (/).
    # Default: quickstart-microsoft-sql-fci-fsx/
    Default: sqlfsx/
    Description: S3 key prefix that is used to simulate a directory for your copy of the
      Quick Start assets. Keep the default prefix unless you are customizing
      the template. Changing this prefix updates code references to point to
      a new Quick Start location. This prefix can include numbers, lowercase
      letters, uppercase letters, hyphens (-), and forward slashes (/). End with
      a forward slash. See https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html
      and https://aws-quickstart.github.io/option1.html.
    Type: String
  VPCID:
    Description: ID of your existing VPC for deployment.
    Type: AWS::EC2::VPC::Id
  SqlFSxServerNetBIOSName1:
    AllowedPattern: "[a-zA-Z0-9\\-]+"
    Default: SqlFSx1
    Description: NetBIOS name of the primary instance. You can use up to 15 characters.
    MaxLength: '15'
    MinLength: '1'
    Type: String
  DomainAdminPassword:
    Description: Password for the domain administrator.
    MaxLength: '32'
    MinLength: '0'
    NoEcho: 'true'
    Type: String
  DomainAdminUser:
    AllowedPattern: "[a-zA-Z0-9]*"
    # Default: StackAdmin
    Default: admin
    Description: User name for the account that will be used as domain administrator.
      This is separate from the default "Administrator" account.
    MaxLength: '25'
    MinLength: '5'
    Type: String
  DomainDNSName:
    AllowedPattern: "[a-zA-Z0-9\\-]+\\..+"
    Default: example.com
    Description: Fully qualified domain name (FQDN).
    MaxLength: '255'
    MinLength: '2'
    Type: String
  ADDnsIpAddresses:
    Description: DNS IP addresses for Active Directory.  Separate these with commas.
    MaxLength: '255'
    MinLength: '2'
    Type: String
    #Delete Default later
    Default: 10.1.20.255,10.1.52.224
  DomainMemberSGID:
    Description: ID of the domain member security group (e.g., sg-9cb7d0e5).
    Type: String
    Default: sg-0cc1466749eb159af
    #AWS::EC2::SecurityGroup::Id
  DomainNetBIOSName:
    AllowedPattern: "[a-zA-Z0-9\\-]+"
    Default: example
    Description: NetBIOS name of the domain for users of earlier
      versions of Windows. You can use up to 15 characters.
    MaxLength: '15'
    MinLength: '1'
    Type: String
  DirectoryId:
    Description: The ID of the AWS Directory Service directory.
    MaxLength: '15'
    MinLength: '1'
    Type: String
    #Delete Default later
    Default: d-9067aec234
  WindowsVersion:
    AllowedValues:
    - Windows_Server-2019-English-Full-Base*
    - Windows_Server-2016-English-Full-Base*
    ConstraintDescription: Must be one of the supported Windows versions.
    Default: Windows_Server-2019-English-Full-Base*
    Description: Select Windows version to run SQL Server.
    Type: String
  WorkloadInstanceType:
    AllowedValues:
    - t3.medium
    - t3a.2xlarge
    - t3.2xlarge
    - r5a.xlarge
    - r5a.2xlarge
    - r5a.4xlarge
    - r5a.8xlarge
    - r5.large
    - r5.xlarge
    - r5.2xlarge
    - r5.4xlarge
    - r5.8xlarge
    - r4.xlarge
    - r4.2xlarge
    - r4.4xlarge
    - r4.8xlarge
    - z1d.large
    - z1d.xlarge
    ConstraintDescription: Must contain a valid instance type.
    # Default: r5.2xlarge
    Default: r5.large
    Description: Type of EC2 instance for the workload instances.
    Type: String
  MSSQLMediaBucketName:
    AllowedPattern: "^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$"
    ConstraintDescription: You can use lowercase letters, uppercase letters, and hyphens (-). Do not start or end with a hyphen (-).
    # Default: ss-experiments
    Default: vedant-sql
    Description: Name of the S3 bucket from which MSSQL media can be downloaded. You can use lowercase letters, uppercase letters, and hyphens (-). Do not start or end with a hyphen (-).
    Type: String
  MSSQLMediaPathKey:
    # Default: quickstart-microsoft-SqlFSx/sql-installation-media/en_sql_server_2019_developer_x64_dvd_baea4195.iso
    Default: SQLServer2019-x64-ENU-Dev.iso
    Description: Key for the S3 bucket from which MSSQL media can be downloaded. You can use numbers, lowercase letters, uppercase letters, hyphens (-), and forward slashes (/).
    Type: String
  SQLAdminAccounts:
    # Default: "contoso\\Administrator"
    Default: "example\\Admin"
    Description: Comma-separated user names will be used as MSSQL DB administrators. It could be Active Directory domain administrators or other local or domain users.
    MaxLength: '25'
    MinLength: '5'
    Type: String
  VPCcidr:
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(1[6-9]|2[0-8]))$
    ConstraintDescription: The CIDR block parameter must be in the form x.x.x.x/16-28.
    Default: 10.0.0.0/16
    Description: CIDR block for the VPC.
    Type: String
Conditions:
  RouteTableIdsExists: !Not [!Equals [!Ref RouteTableIDs, ""]]
Rules:
  KeyPairsNotEmpty:
    Assertions:
    - Assert:
        Fn::Not:
        - Fn::EachMemberEquals:
          - Fn::RefAll: AWS::EC2::KeyPair::KeyName
          - ''
      AssertDescription: All key pair parameters must not be empty
  SubnetsInVPC:
    Assertions:
    - Assert:
        Fn::EachMemberIn:
        - Fn::ValueOfAll:
          - AWS::EC2::Subnet::Id
          - VpcId
        - Fn::RefAll: AWS::EC2::VPC::Id
      AssertDescription: All subnets must in the VPC
Resources:
  ADAdminSecrets:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'AWSQuickStart/${AWS::StackName}/ADAdminSecrets'
      Description: Active Directory administrator credentials for Quick Start
      SecretString: !Sub '{ "username" : "${DomainAdminUser}", "password" : "${DomainAdminPassword}" }'
  SQLAutomationLogs:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/Quick_Start/${AWS::StackName}'
      RetentionInDays: 30
  WindowsBaseAMIInfo:
    Type: Custom::WindowsBaseAMIInfo
    Properties:
      ServiceToken:
        Fn::GetAtt:
        - AMIInfoFunction
        - Arn
      Region:
        Ref: AWS::Region
      AMIName: !Ref WindowsVersion
  AMIInfoFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile:
          Fn::Join:
          - ''
          - - "/**\n"
            - "* A Lambda function that looks up the latest AMI ID for a given region
              and architecture.\n"
            - "**/\n"
            - 'var aws = require("aws-sdk");'
            - 'exports.handler = function(event, context) {'
            - '    console.log("REQUEST RECEIVED:\n" + JSON.stringify(event));'
            - "    // For Delete requests, immediately send a SUCCESS response.\n"
            - '    if (event.RequestType == "Delete") {'
            - '        sendResponse(event, context, "SUCCESS");'
            - "        return;\n"
            - "    }\n"
            - '    var responseStatus = "FAILED";'
            - "    var responseData = {};\n"
            - "    var ec2 = new aws.EC2({region: event.ResourceProperties.Region});\n"
            - "    var describeImagesParams = {\n"
            - '        Filters: [{ Name: "name", Values: [event.ResourceProperties.AMIName]}],'
            - '        Owners: ["amazon"]'
            - "    };\n"
            - "    // Get AMI IDs with the specified name pattern and owner\n"
            - "    ec2.describeImages(describeImagesParams, function(err, describeImagesResult)
              {\n"
            - "        if (err) {\n"
            - '            responseData = {Error: "DescribeImages call failed"};'
            - '            console.log(responseData.Error + ":\n", err);'
            - "        }\n"
            - "        else {\n"
            - "            var images = describeImagesResult.Images;\n"
            - "            // Sort images by name in decscending order. The names
              contain the AMI version, formatted as YYYY.MM.Ver.\n"
            - "            images.sort(function(x, y) { return y.CreationDate.localeCompare(x.CreationDate);
              });\n"
            - "            for (var j = 0; j < images.length; j++) {\n"
            - "                if (isBeta(images[j].Name)) continue;\n"
            - '                responseStatus = "SUCCESS";'
            - '                responseData["Id"] = images[j].ImageId;'
            - "                break;\n"
            - "            }\n"
            - "        }\n"
            - "        sendResponse(event, context, responseStatus, responseData);\n"
            - "    });\n"
            - "};\n"
            - "\n"
            - "// Check if the image is a beta or rc image. The Lambda function won't
              return any of those images.\n"
            - 'function isBeta(imageName) {'
            - '    return imageName.toLowerCase().indexOf("beta") > -1 || imageName.toLowerCase().indexOf(".rc")
              > -1;'
            - "}\n"
            - "// Send response to the pre-signed S3 URL \n"
            - 'function sendResponse(event, context, responseStatus, responseData)
              {'
            - "    var responseBody = JSON.stringify({\n"
            - "        Status: responseStatus,\n"
            - '        Reason: "See the details in CloudWatch Log Stream: " + context.logStreamName,'
            - "        PhysicalResourceId: context.logStreamName,\n"
            - "        StackId: event.StackId,\n"
            - "        RequestId: event.RequestId,\n"
            - "        LogicalResourceId: event.LogicalResourceId,\n"
            - "        Data: responseData\n"
            - "    });\n"
            - '    console.log("RESPONSE BODY:\n", responseBody);'
            - '    var https = require("https");'
            - '    var url = require("url");'
            - "    var parsedUrl = url.parse(event.ResponseURL);\n"
            - "    var options = {\n"
            - "        hostname: parsedUrl.hostname,\n"
            - "        port: 443,\n"
            - "        path: parsedUrl.path,\n"
            - '        method: "PUT",'
            - "        headers: {\n"
            - '            "content-type": "",'
            - '            "content-length": responseBody.length'
            - "        }\n"
            - "    };\n"
            - '    console.log("SENDING RESPONSE...\n");'
            - "    var request = https.request(options, function(response) {\n"
            - '        console.log("STATUS: " + response.statusCode);'
            - '        console.log("HEADERS: " + JSON.stringify(response.headers));'
            - "        // Tell AWS Lambda that the function execution is done  \n"
            - "        context.done();\n"
            - "    });\n"
            - '    request.on("error", function(error) {'
            - '        console.log("sendResponse Error:" + error);'
            - "        // Tell AWS Lambda that the function execution is done  \n"
            - "        context.done();\n"
            - "    });\n"
            - "    // write data to request body\n"
            - "    request.write(responseBody);\n"
            - "    request.end();\n"
            - "}"
      Handler: index.handler
      Role:
        Fn::GetAtt:
        - AMIInfoFunctionLambdaExecutionRole
        - Arn
      Runtime: nodejs12.x
      Timeout: 30
  AMIInfoFunctionLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: !Sub 'arn:${AWS::Partition}:logs:*:*:*'
          - Effect: Allow
            Action:
            - ec2:DescribeImages
            Resource: "*"
  SqlFSxAutomationRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyWildcardResource
            - EIAMPolicyActionWildcard
    Properties:
      Policies:
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub ['arn:${AWS::Partition}:s3:::${S3Bucket}/*', S3Bucket: !Ref QSS3BucketName]
                  - !Sub ['arn:${AWS::Partition}:s3:::${S3Bucket}', S3Bucket: !Ref QSS3BucketName]
                Effect: Allow
          PolicyName: aws-quick-start-s3-policy
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:SignalResource
                Resource: !Sub 'arn:${AWS::Partition}:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*'
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ec2:DescribeInstanceStatus
                  - ec2:StopInstances
                  - ec2:StartInstances
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DescribeSubnets
                  - ssm:*
                  - lambda:*
                  - fsx:Describe*
                  - fsx:ListTagsForResource
                Resource: '*'
          PolicyName: SqlFSx-SSM-AutomationExecution
      Path: /
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Principal:
              Service:
                - ec2.amazonaws.com
                - ssm.amazonaws.com
            Effect: Allow
        Version: '2012-10-17'
  SqlFSxAutomation:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Automation
      Content:
        schemaVersion: "0.3"
        description: Deploy SqlFSx with SSM Automation
        # Role that is utilized to perform the steps within the Automation Document.
        assumeRole: "{{AutomationAssumeRole}}"
        # Gathering parameters needed to configure DCs in the Quick Start
        parameters:
          DomainDNSName:
            default: !Sub "${DomainDNSName}"
            description: "Fully qualified domain name (FQDN) of the forest root domain."
            type: "String"
          DomainNetBIOSName:
            default: !Sub "${DomainNetBIOSName}"
            description: 'NetBIOS name of the domain for users of earlier versions of Windows. You can use up to 15 characters.'
            type: "String"
          DirectoryId:
            default: !Sub "${DirectoryId}"
            description: "The ID of the AWS Directory Service directory (e.g., d-97672886b5)."
            type: "String"
          ADDnsIpAddresses:
            default: !Sub "${ADDnsIpAddresses}"
            description: "The IP addresses of the DNS servers in the directory. Required when DHCP is not configured."
            type: "String"
          MSSQLMediaBucketName:
            default: !Sub "${MSSQLMediaBucketName}"
            description: "The S3 bucket from which MSSQL media can be downloaded."
            type: "String"
          MSSQLMediaPathKey:
            default: !Sub "${MSSQLMediaPathKey}"
            description: "The key for the S3 bucket from which MSSQL media can be downloaded."
            type: "String"
          SQLAdminAccounts:
            default: !Sub "${SQLAdminAccounts}"
            description: "MSSQL administrator accounts"
            type: "String"
          AdminSecrets:
            default: !Sub "${ADAdminSecrets}"
            description: "Domain administrator credentials"
            type: "String"
          SqlFSxInstanceId:
            default: ""
            description: "ID of the SqlFSx instance"
            type: "String"
          SqlFSxInstanceIP:
            default: ""
            description: "ID of the SqlFSx instance"
            type: "String"
          StackName:
            default: !Sub "${AWS::StackName}"
            description: "CloudFormation stack name"
            type: "String"
          SqlFSxServerNetBIOSName1:
            default: !Sub "${SqlFSxServerNetBIOSName1}"
            description: "CloudFormation stack name"
            type: "String"
          AutomationAssumeRole:
            default: ""
            description: "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf."
            type: "String"
          WindowsVersion:
            default: !Sub "${WindowsVersion}"
            description: "The AMI used to deploy SqlFSx instance."
            type: "String"
          URLSuffix:
            description: "AWS URL suffix"
            type: "String"
          QSS3BucketName:
            default: "aws-quickstart"
            description: "S3 bucket name for the Quick Start assets. Quick Start bucket name can include numbers, lowercase letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen (-)."
            type: "String"
          QSS3KeyPrefix:
            default: "quickstart-microsoft-sql/"
            description: "S3 key prefix for the Quick Start assets. Quick Start key prefix can include numbers, lowercase letters, uppercase letters, hyphens (-), and forward slash (/)."
            type: "String"
          FSxMgmtIp:
            default: !Sub "${CustomFSXResource.FSMgmtIP}"
            description: "FSxMgmtIP."
            type: "String"
          FSxSVMIscsiIP1:
            default: !Sub "${CustomFSXResource.FsxSvmIscsiIP2}"
            description: "FSxSVMIscsiIP2."
            type: "String"
          FSxSVMIscsiIP2:
            default: !Sub "${CustomFSXResource.FsxSvmIscsiIP1}"
            description: "FSxSVMIscsiIP1."
            type: "String"
          CustomFsxCmdFunction:
            default: !Ref CustomFsxCmdFunction
            description: "Custom FSx function."
            type: "String"
          SVMName:
            default: !Sub "${CustomFSXResource.SVMName}"
            description: "SVM Name."
            type: "String"
          LUNSize:
            default: !Sub "${CustomFSXResource.lun_size}"
            description: "LUN Size."
            type: "String"
          FSxAdminPassword:
            default: !Sub "${FSxAdminPassword}"
            description: "FSx Admin Password"
            type: "String"

          
        mainSteps:
        - name: GetAllClusterNodes
          action: 'aws:executeAwsApi'
          outputs:
            - Name: InstanceIds
              Selector: $.Reservations..Instances..InstanceId
              Type: StringList
          inputs:
            Service: ec2
            Api: DescribeInstances
            Filters:
              - Name: 'tag:Name'
                Values:
                  - Ref: SqlFSxServerNetBIOSName1
              - Name: instance-state-name
                Values:
                  - running
          description: Get instances
        - name: GetClusterNode1
          action: 'aws:executeAwsApi'
          outputs:
            - Name: InstanceIds
              Selector: $.Reservations..Instances..InstanceId
              Type: StringList
          inputs:
            Service: ec2
            Api: DescribeInstances
            Filters:
              - Name: 'tag:Name'
                Values:
                  - Ref: SqlFSxServerNetBIOSName1
              - Name: instance-state-name
                Values:
                  - running
          description: Get instances
        - name: FindSecondaryIpAddresses
          action: 'aws:executeScript'
          onFailure: "step:signalfailure"
          inputs:
            Runtime: PowerShell Core 6.0
            Script:
                |
                 $inputPayload = $env:InputPayload | ConvertFrom-Json;
                 Install-Module AWS.Tools.EC2 -Force
                 Import-Module AWS.Tools.EC2

                 #Function to find Subnet
                 function Get-SubnetMask($i)
                 {
                    $instance = $i
                    $subnetid = $instance.instances[0].NetworkInterfaces.SubnetId
                    $subnet = get-ec2subnet -SubnetId $subnetid
                    $cidr = $subnet.CidrBlock
                    $cidr_mask = $cidr.split('/')[1]
                    $A = 0
                    $A_Index = 8
                    $B = 0
                    $B_Index = 16
                    $C = 0
                    $C_Index = 24
                    $D = 0
                    $D_Index = 32
                    for ($i = 1; $i -le $cidr_mask; $i++)
                    {
                        if ($i -le $A_Index)
                        {
                            $A += ([Math]::Pow(2, 8 - $i))
                        }
                        elseif ($i -le $B_Index)
                        {
                            $B += ([Math]::Pow(2, 8 - $i + $A_Index))
                        }
                        elseif ($i -le $C_Index)
                        {
                            $C += ([Math]::Pow(2, 8 - $i + $B_Index))
                        }
                        elseif ($i -le $D_Index)
                        {
                            $D += ([Math]::Pow(2, 8 - $i + $C_Index))
                        }
                    }
                    $subnet_mask = "{0}.{1}.{2}.{3}" -f $A, $B, $C, $D
                    return $subnet_mask
                 }

                 $instanceIds = $inputPayload.parameter

                 $resultStr = ""
                 $subnetMaskStr = ""

                 #Finding secondary IP addresses of the primary instance
                 foreach ($i in $instanceIds)
                 {
                   $instance = get-ec2instance -InstanceId $i
                   $tags = $instance.instances[0].Tags
                   foreach ($t in $tags)
                   {
                       $IPs = $instance.instances[0].NetworkInterfaces.PrivateIpAddresses
                       $ip1 = $IPs[1].PrivateIpAddress
                       $ip2 = $IPs[2].PrivateIpAddress
                       $resultStr = "{0};{1}" -f $ip1, $ip2

                       $subnetMaskStr = Get-SubnetMask($instance)
                       break;
                   }
                   if ([System.String]::IsNullOrEmpty($resultStr) -Eq $False)
                   {
                     break;
                   }
                 }
                 $resultStr = "{0};{1}" -f $resultStr, $subnetMaskStr

                 Write-Host $dnsName
                 return @{message=$resultStr}
            InputPayload:
              parameter: '{{GetAllClusterNodes.InstanceIds}}'
          outputs:
            - Name: SecondaryPrivateIpAddresses
              Selector: $.Payload.message
              Type: String
        #Preparing requisites
        - name: "UpdateSSMAgent"
          action: "aws:runCommand"
          timeoutSeconds: 300
          onFailure: "Continue"
          inputs:
            DocumentName: AWS-UpdateSSMAgent
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
        - name: "InitializeDisk"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: AWS-RunPowerShellScript
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              commands:
                - |
                   C:\ProgramData\Amazon\EC2-Windows\Launch\Scripts\InitializeDisks.ps1
        # Joining to AD
        - name: "JoinAD"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-JoinDirectoryServiceDomain"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              directoryId: "{{DirectoryId}}"
              directoryName: "{{DomainDNSName}}"
              dnsIpAddresses: !Select [0, !Split [",", !Ref ADDnsIpAddresses]]
        - name: "EnableCredSSP"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-RunRemoteScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              sourceType: "S3"
              sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/enable-CredSSP.ps1"}'
              commandLine: "./enable-CredSSP.ps1 -DomainDNSName '{{DomainDNSName}}'"

        - name: "IscsiInitiator"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-RunRemoteScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              sourceType: "S3"
              sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/IscsiInitiator.ps1"}'
              commandLine: "./IscsiInitiator.ps1 -AdminSecret '{{AdminSecrets}}' -DomainNetBIOSName {{DomainNetBIOSName}}"
        
        - name: "IQNRetrival"
          action: "aws:runCommand"
          inputs:
            DocumentName: "AWS-RunPowerShellScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            Parameters:
              commands: |
                $iqn = (Get-InitiatorPort).NodeAddress
                $output = @{
                  iqn = $iqn
                }
                Write-Output ($iqn | ConvertTo-Json -Depth 100 -Compress)
          outputs:
            - Name: "IqnValue"
              Selector: "$.AutomationExecution.Outputs['IQNRetrival'].CommandInvocation.Stdout"
              Type: String

        - name: IQNParse
          action: 'aws:executeScript'
          onFailure: "step:signalfailure"
          inputs:
            Runtime: PowerShell Core 6.0
            Script:
                |
                 $inputPayload = $env:InputPayload | ConvertFrom-Json;
                 $iqn = $inputPayload.parameter

                 $resultStr = $iqn.Replace(" ", "").Trim().Replace('"','')
                 
                 $resultStr = "{0}" -f $resultStr

                 Write-Host $resultStr
                 return @{message=$resultStr}
            InputPayload:
              parameter: '{{IQNRetrival.Output}}'
          outputs:
            - Name: Iqn
              Selector: $.Payload.message
              Type: String

        - name: "MPIOSetup"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-RunRemoteScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              sourceType: "S3"
              sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/MPIOSetup.ps1"}'
              commandLine: "./MPIOSetup.ps1 -AdminSecret '{{AdminSecrets}}' -DomainNetBIOSName {{DomainNetBIOSName}}"
          

        #password should not be hardcoded
        - name: 'InvokeSMBConfigLambda'
          action: 'aws:invokeLambdaFunction'
          inputs:
            FunctionName: '{{CustomFsxCmdFunction}}'
            Payload: !Sub
              - '{ "ResourceRef1": "fsxadmin:${FSxAdminPassword}",
                  "ResourceRef2": "${FSxMgmtIp}",
                  "ResourceRef3": "${TrimmedIQN}",
                  "ResourceRef4": "windows_2008",
                  "ResourceRef5": "${SVMName}",
                  "ResourceRef7": "${LUNSize}"
                }'
              - FSxAdminPassword: '{{FSxAdminPassword}}'
                FSxMgmtIp: '{{FSxMgmtIp}}'
                TrimmedIQN: '{{IQNParse.Iqn}}'
                SVMName: '{{SVMName}}'
                LUNSize: '{{LUNSize}}'

        - name: "MountIscsiDiskOnInstance"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-RunRemoteScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              sourceType: "S3"
              sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/MountIscsiDiskOnInstance.ps1"}'
              commandLine: "./MountIscsiDiskOnInstance.ps1 -AdminSecret '{{AdminSecrets}}' -DomainNetBIOSName {{DomainNetBIOSName}} -FSxSVMIscsiIP1 {{FSxSVMIscsiIP1}} -FSxSVMIscsiIP2 {{FSxSVMIscsiIP2}} -SqlFSxInstanceIP {{SqlFSxInstanceIP}} -LUNSize {{LUNSize}}"

        # Installing MSSQL FCI
        - name: "PrepareFCI"
          action: "aws:runCommand"
          onFailure: "step:signalfailure"
          inputs:
            DocumentName: "AWS-RunRemoteScript"
            InstanceIds: '{{GetAllClusterNodes.InstanceIds}}'
            CloudWatchOutputConfig:
              CloudWatchOutputEnabled: "true"
              CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
            Parameters:
              sourceType: "S3"
              sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/prepare-fci.ps1"}'
              commandLine: "./prepare-fci.ps1 -AdminSecret '{{AdminSecrets}}' -DomainNetBIOSName {{DomainNetBIOSName}} -SqlUserSecret {{AdminSecrets}} -MSSQLMediaBucket '{{MSSQLMediaBucketName}}' -MSSQLMediaKey '{{MSSQLMediaPathKey}}'"
        # this is using the SqlShare
        # check modifications here
        # - name: "CompleteFCI"
        #   action: "aws:runCommand"
        #   onFailure: "step:signalfailure"
        #   inputs:
        #     DocumentName: "AWS-RunRemoteScript"
        #     InstanceIds: '{{GetClusterNode1.InstanceIds}}'
        #     CloudWatchOutputConfig:
        #       CloudWatchOutputEnabled: "true"
        #       CloudWatchLogGroupName: !Ref 'SQLAutomationLogs'
        #     Parameters:
        #       sourceType: "S3"
        #       sourceInfo: !Sub '{"path": "https://{{QSS3BucketName}}.s3.{{URLSuffix}}/{{QSS3KeyPrefix}}/complete-fci.ps1"}'
        #       commandLine: "./complete-fci.ps1 -AdminSecret '{{AdminSecrets}}' -DomainNetBIOSName {{DomainNetBIOSName}} -FileServerPath '{{FSxSVMIscsiIP1}}' -Node1FciIp '{{FindSecondaryIpAddresses.SecondaryPrivateIpAddresses}}'.split(';')[1] -Node1SubnetMask '{{FindSecondaryIpAddresses.SecondaryPrivateIpAddresses}}'.split(';')[4] -Node2FciIp '{{FindSecondaryIpAddresses.SecondaryPrivateIpAddresses}}'.split(';')[3] -Node2SubnetMask '{{FindSecondaryIpAddresses.SecondaryPrivateIpAddresses}}'.split(';')[5] -FCIName {{SqlFSxFCIName}} -SQLAdminAccounts '{{SQLAdminAccounts}}'"
        #End of deployment workflow


        # Determines if CFN Needs to be Signaled or if Workflow should just end
        - name: CFNSignalEnd
          action: aws:branch
          inputs:
            Choices:
            - NextStep: signalsuccess
              Not:
                Variable: "{{StackName}}"
                StringEquals: ""
            - NextStep: sleepend
              Variable: "{{StackName}}"
              StringEquals: ""
        # If all steps complete successfully signals CFN of Success
        - name: "signalsuccess"
          action: "aws:executeAwsApi"
          isEnd: True
          inputs:
            Service: cloudformation
            Api: SignalResource
            LogicalResourceId: "SSMWaitCondition"
            StackName: "{{StackName}}"
            Status: SUCCESS
            UniqueId: "{{SqlFSxInstanceId}}"
        # If CFN Signl Not Needed this sleep ends work flow
        - name: "sleepend"
          action: "aws:sleep"
          isEnd: True
          inputs:
            Duration: PT1S
        # If any steps fails signals CFN of Failure
        - name: "signalfailure"
          action: "aws:executeAwsApi"
          inputs:
            Service: cloudformation
            Api: SignalResource
            LogicalResourceId: "SSMWaitCondition"
            StackName: "{{StackName}}"
            Status: FAILURE
            UniqueId: "{{SqlFSxInstanceId}}"
  SqlFSxSSMPassRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: SqlFsx-SSM-PassRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${SqlFSxAutomationRole}'
      Roles:
        - !Ref 'SqlFSxAutomationRole'
  SqlFSxInstance1:
    Type: AWS::EC2::Instance
    Properties:
      ImageId:
        Fn::GetAtt:
        - WindowsBaseAMIInfo
        - Id
      IamInstanceProfile:
        Ref: SqlFSxProfile
      InstanceType:
        Ref: WorkloadInstanceType
      NetworkInterfaces:
      - DeleteOnTermination: true
        DeviceIndex: '0'
        SubnetId:
          Ref: PrivateSubnet1ID
        SecondaryPrivateIpAddressCount: 2
        GroupSet:
          - Ref: DomainMemberSGID
          - Ref: WorkloadSecurityGroup
      Tags:
      - Key: Name
        Value:
          Ref: SqlFSxServerNetBIOSName1
      - Key: Group
        Value: "FSxAutomation"
      BlockDeviceMappings:
      - DeviceName: "/dev/sda1"
        Ebs:
          VolumeSize: 100
          VolumeType: gp2
      KeyName:
        Ref: KeyPairName
      UserData: !Base64
        Fn::Join:
          - ''
          - - "<powershell>\n"
            - "New-Item -Path C:\\ -Name log -ItemType Directory \n"
            - "$transcriptPath = 'C:\\log\\user-data-transcript.txt' \n"
            - "Start-Transcript $transcriptPath \n"
            - !Sub 'Set-Content -Value "${SqlFSxServerNetBIOSName1}" -Path C:\log\hostname.txt'
            - "\n"
            - !Sub 'Rename-Computer -NewName "${SqlFSxServerNetBIOSName1}"'
            - "\n"
            - "$instanceId = (New-Object System.Net.WebClient).DownloadString('http://169.254.169.254/latest/meta-data/instance-id')\n"
            - "$instanceIp = (New-Object System.Net.WebClient).DownloadString('http://169.254.169.254/latest/meta-data/local-ipv4')\n"
            - 'Start-SSMAutomationExecution -DocumentName '
            - !Sub '"${SqlFSxAutomation}"'
            - ' -Parameter @{'
            - '"SqlFSxInstanceId"='
            - "$instanceId"
            - ';"SqlFSxInstanceIP"='
            - "$instanceIp"
            - ';"URLSuffix"='
            - !Sub '"${AWS::URLSuffix}"'
            - ';"QSS3BucketName"='
            - !Sub '"${QSS3BucketName}"'
            - ';"QSS3KeyPrefix"='
            - !Sub '"${QSS3KeyPrefix}"'
            - ';"AutomationAssumeRole"='
            - !Sub '"arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${SqlFSxAutomationRole}"'
            - '}'
            - "\n"
            - "</powershell>\n"

  SqlFSxRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - EIAMPolicyActionWildcard
            - EIAMPolicyWildcardResource
    Properties:
      Policies:
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Action:
            - s3:GetObject
            Resource:
            - !Sub ['arn:${AWS::Partition}:s3:::${S3Bucket}/*', S3Bucket: !Ref QSS3BucketName]
            Effect: Allow
          - Action:
            - s3:*
            Resource: "*"
            Effect: Allow
        PolicyName: aws-quick-start-s3-policy
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - secretsmanager:GetSecretValue
                - secretsmanager:DescribeSecret
              Resource:
                - !Ref 'ADAdminSecrets'
            - Effect: Allow
              Action:
                - ssm:StartAutomationExecution
              Resource: '*'
        PolicyName: QS-SqlFSx-SSM
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - ds:*
              Resource:
                - "*"
        PolicyName: QS-SqlFSx-DS
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action:
                - iam:PassRole
              Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${SqlFSxAutomationRole}'
        PolicyName: QS-SqlFSx-SSM-PassRole
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action: "*"
              Resource: "*"
        PolicyName: AdminPolicy_TBC
      ManagedPolicyArns:
      - !Sub "arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore"
      Path: "/"
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Principal:
            Service:
            - ec2.amazonaws.com
          Effect: Allow
        Version: '2012-10-17'
  SqlFSxProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - Ref: SqlFSxRole
      Path: "/"
  SSMWaitHandle:
    Type: AWS::CloudFormation::WaitConditionHandle
  SSMWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    CreationPolicy:
      ResourceSignal:
        Timeout: PT120M
        Count: 1
    DependsOn: "SqlFSxInstance1"
    Properties:
      Handle:
        Ref: "SSMWaitHandle"
      Timeout: "7200"
      Count: 1
  WorkloadSecurityGroup:
   Type: AWS::EC2::SecurityGroup
   Properties:
     GroupDescription: Allow access to the Workload instances
     VpcId:
       Ref: VPCID
     SecurityGroupIngress:
     - IpProtocol: '-1'
       FromPort: -1
       ToPort: -1
       CidrIp: "0.0.0.0/0"
       # CidrIp:
       #   Ref: VPCcidr

  LambdaBasicExecutionRoleOntap:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com 
          Action: sts:AssumeRole
      Policies:
        - PolicyName: RDSFsxCustomAutomationLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - fsx:DescribeFileSystems
                  - fsx:DescribeStorageVirtualMachines
                Resource:
                  - !Sub arn:aws:fsx:${AWS::Region}:${AWS::AccountId}:file-system/*
                  - !Sub arn:aws:fsx:${AWS::Region}:${AWS::AccountId}:storage-virtual-machine/*
              - Effect: Allow
                Action:
                  - s3:GetBucketLocation
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::*
                  - !Sub arn:aws:s3:::*/*
              - Effect: Allow
                Action:
                  - ssm:SendCommand
                  - ssm:GetDocument
                  - ssm:DescribeDocument
                  - ssm:GetManifest
                  - ssm:GetParameter
                  - ssm:GetParameters
                  - ssm:GetCommandInvocation
                  - ssm:ListCommandInvocations
                  - ec2:DescribeRouteTables
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                Resource: '*'
  CustomFSXResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt 'CustomFunction.Arn'
      ResourceRef1: !Ref FSxOntapStorageVirtualMachine
      ResourceRef2: !Ref FSxOntapFileSystem
      ResourceRef4: !Sub ${VPCID}
      ResourceRef5: !Sub ${FileShareVolumeSize}
  CustomFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Retrieves ONTAP FSx DNS name and gets IQN value from custom RDS EC2"
      Timeout: 300
      Role: !GetAtt 'LambdaBasicExecutionRoleOntap.Arn'
      Runtime: python3.7
      Code:
        ZipFile: |
          import json
          import logging
          import cfnresponse
          import boto3
          import time
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          def lambda_handler(event, context):
            logger.info('got event {}'.format(event))
            try:
              responseData = {}
              if event['RequestType'] == 'Delete':
                logger.info('Incoming RequestType: Delete operation')
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              if event['RequestType'] in ["Create", "Update"]:
                # 1. retrieve resource reference ID or Name
                ResourceRef1=event['ResourceProperties']['ResourceRef1']
                ResourceRef2=event['ResourceProperties']['ResourceRef2']
                ResourceRef4=event['ResourceProperties']['ResourceRef4']
                ResourceRef5=event['ResourceProperties']['ResourceRef5']

                # 2. retrieve boto3 client
                client = boto3.client('fsx')
                # 3. Invoke describe/retrieve function using ResourceRef
                response = client.describe_storage_virtual_machines(StorageVirtualMachineIds=[ResourceRef1], Filters=[{'Name': 'file-system-id','Values': [ResourceRef2,]},])
                responseFs = client.describe_file_systems(FileSystemIds=[ResourceRef2])
                # 4. Parse and return required attributes
                responseData = {}
                responseData['SVMName']= response.get('StorageVirtualMachines')[0].get('Name')
                logger.info('Retrieved SVMName!')
                responseData['SVMDNSName']= response.get('StorageVirtualMachines')[0].get('Endpoints').get('Iscsi').get('DNSName')
                logger.info('Retrieved SVMDNSName!')
                responseData['FSMgmtIP'] = responseFs.get('FileSystems')[0].get('OntapConfiguration').get('Endpoints').get('Management').get('IpAddresses')[0]
                logger.info('Retrieved FSMgmtIP!')
                responseData['route_table_id'] = responseFs.get('FileSystems')[0].get('OntapConfiguration').get('RouteTableIds')[0]
                logger.info('Retrieved Route Table ID')
                responseData['FsxSvmIscsiIP1'] = response.get('StorageVirtualMachines')[0].get('Endpoints').get('Iscsi').get('IpAddresses')[0]
                responseData['FsxSvmIscsiIP2'] = response.get('StorageVirtualMachines')[0].get('Endpoints').get('Iscsi').get('IpAddresses')[1]
                logger.info('Retrieved FsxSvmIscsiIP!')
                responseData['SVMMgmtIP'] = response.get('StorageVirtualMachines')[0].get('Endpoints').get('Management').get('IpAddresses')[0]

                # calculate lun size
                # Lun size calculation
                if int(ResourceRef5) >= 0:
                  lun_size = round((int(ResourceRef5)/1024)/1.1)
                  responseData['lun_size'] = lun_size
                else:
                  logger.error("Error with Lun size calculations")
                  responseData = {"Data": ResourceRef5}
                  cfnresponse.send(event,context,cfnresponse.FAILED,responseData)


                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
              else:
                logger.info('Unexpected RequestType!')
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
            except Exception as err:
              logger.error(err)
              responseData = {"Data": str(err)}
              cfnresponse.send(event,context,cfnresponse.FAILED,responseData)
            return

  LambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      CompatibleArchitectures:
        - x86_64
      CompatibleRuntimes:
        - python3.7
      Content:
        S3Bucket: !Sub ${QSS3BucketName}
        S3Key: packages.zip
      LayerName: pythonRequests

  CustomFsxCmdFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Run Commands on FSX"
      Timeout: 120
      Role: !GetAtt 'LambdaBasicExecutionRoleOntap.Arn'
      Runtime: python3.7
      Layers:
        - !Ref LambdaLayer
      VpcConfig:
        SecurityGroupIds:
          - !Ref WorkloadSecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1ID
          - !Ref PrivateSubnet2ID
      Code:
        ZipFile: |
          import json
          import logging
          import requests
          import time
          import base64
          import boto3

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
            logger.info('got event {}'.format(event))

            try:
              responseData = {}

              # 1. retrieve resource reference ID or Name
              ResourceRef1=event['ResourceRef1']
              ResourceRef2=event['ResourceRef2']
              ResourceRef3=event['ResourceRef3']
              ResourceRef4=event['ResourceRef4']
              ResourceRef5=event['ResourceRef5']
              ResourceRef7=event['ResourceRef7']

              ResourceRef1 = ResourceRef1.encode("ascii")
              ResourceRef1=base64.b64encode(ResourceRef1)
              ResourceRef1 = ResourceRef1.decode("utf-8")

              # ssm = boto3.client('ssm')
              # responsessm = ssm.get_parameter(Name='/netappautomation/sql/iqnvalue', WithDecryption=True)
              # ResourceRef3 = responsessm['Parameter']['Value']
               
              #Code for Windows ISCSI initiator config
              if "windows" in ResourceRef4:
                OsIgrp = "windows"
              else:
                OsIgrp = ResourceRef4

              #IGroup creation
              url = "https://{}/api/protocols/san/igroups".format(ResourceRef2)
              headers = {
                  'authorization': 'Basic {}'.format(ResourceRef1),
                  'content-type': "application/json",
                  'accept': "application/json"
              }
              payload = {
                "protocol": "iscsi",
                "initiators.name": [ResourceRef3],
                "name": "sqligrp",
                "os_type": OsIgrp,
                "svm.name": ResourceRef5
              }
              response = requests.post(url, headers=headers, json=payload, verify=False)

              time.sleep(2)
              check1 = requests.get(url, headers=headers, verify=False)
              check1 = str(check1.json())
              if (check1.find("sqligrp") != -1):
                  pass
              else:
                  err = "Igroup Creation Failed"+str(check1)
                  logger.error(err)
                  responseData = {"Data": str(err)}

              #Lun Creation
              url = "https://{}/api/storage/luns".format(ResourceRef2)
              payload = {
                "svm.name": ResourceRef5,
                "location.volume.name": "sqlvol",
                "name": "/vol/sqlvol/sqllun",
                "os_type": ResourceRef4,
                "space.size": str(ResourceRef7)+"G"
              }
              response = requests.post(url, headers=headers, json=payload, verify=False)
              time.sleep(2)

              check3 = requests.get(url, headers=headers, verify=False)
              check3 = str(check3.json())

              if (check3.find("/vol/sqlvol/sqllun") != -1):
                  pass
              else:
                  err = "LUN Creation Failed"+str(check3)
                  logger.error(err)
                  responseData = {"Data": str(err)}

              #Lun Mapping
              url = "https://{}/api/protocols/san/lun-maps".format(ResourceRef2)
              payload = {
                "svm.name": ResourceRef5,
                "lun.name": "/vol/sqlvol/sqllun",
                "igroup.name": "sqligrp"
              }
              response = requests.post(url, headers=headers, json=payload, verify=False)
              time.sleep(2)

              check4 = requests.get(url, headers=headers, verify=False)
              check4 = str(check4.json())

              if (check4.find("/sqlvol/sqllun") != -1):
                  pass
              else:
                  err = "LUN Mapping Failed"+str(check4)
                  logger.error(err)
                  responseData = {"Data": str(err)}
            
            except Exception as err:
              logger.error(err)
              responseData = {"Data": str(err)}
            return

  FSxOntapFileSystem:
    Type: 'AWS::FSx::FileSystem'
    Properties:
      FileSystemType: ONTAP
      StorageCapacity:
        Ref: FileShareStorageCapacity
      # StorageType: SSD
      SubnetIds:
        - Ref: PrivateSubnet1ID
        - Ref: PrivateSubnet2ID
      SecurityGroupIds:
        - Ref: WorkloadSecurityGroup
        - Ref: DomainMemberSGID
      Tags:
        - Key: Name
          Value: SqlFSxFileSystem
      OntapConfiguration:
        WeeklyMaintenanceStartTime: '4:16:30'
        DailyAutomaticBackupStartTime: '01:00'
        AutomaticBackupRetentionDays: 30
        DeploymentType: MULTI_AZ_1
        PreferredSubnetId: !Ref PrivateSubnet1ID
        ThroughputCapacity: !Ref FileShareThroughputCapacity
        #Password can be stored in Secrets manager and referenced from there
        FsxAdminPassword: !Ref FSxAdminPassword
        RouteTableIds: 
          Fn::If:
            - RouteTableIdsExists
            - Fn::Split: [",", Ref: RouteTableIDs]
            - !Ref "AWS::NoValue"
        # ActiveDirectoryId: !Sub '${DirectoryId}'
  FSxOntapStorageVirtualMachine:
    Type: AWS::FSx::StorageVirtualMachine
    Properties:
      FileSystemId: !Ref FSxOntapFileSystem
      Name: "SqlFSxSVM"
      RootVolumeSecurityStyle: NTFS
      ActiveDirectoryConfiguration:
        # Max string length 15. Since this is bound to a SVM and a File System, we don't need the env or service name.
        NetBiosName: "SqlFSxSVM"
        SelfManagedActiveDirectoryConfiguration:
          OrganizationalUnitDistinguishedName: !Sub OU=Computers,OU=${DomainNetBIOSName},DC=${DomainNetBIOSName},DC=com
          FileSystemAdministratorsGroup: AWS Delegated FSx Administrators
          DomainName: !Ref DomainDNSName
          # Must pass the comma delimited string in as a parameter, because {{resolve:ssm:}} can't
          # be nested inside a Fn::Split. The split happens before the resolution of the parameter.
          DnsIps: !Split [',', !Ref ADDnsIpAddresses]
          # Don't use Domain\Username here - only Username
          UserName: !Ref DomainAdminUser
          # Can't use ssm-secure here
          Password: !Ref DomainAdminPassword
      Tags:
        - Key: Name
          Value: SqlFSxSVM
  FSxOntapVolume:
    Type: AWS::FSx::Volume
    Properties:
      VolumeType: ONTAP
      Name: sqlvol
      OntapConfiguration:
        JunctionPath: /sqlvol
        SecurityStyle: NTFS
        SizeInMegabytes: !Ref FileShareVolumeSize
        StorageEfficiencyEnabled: 'false' # Quoted to make cfn-lint happy
        StorageVirtualMachineId: !Ref FSxOntapStorageVirtualMachine

Outputs:
  InstanceIP:
    Description: "Private IP address of SqlFSx instance."
    Value: !GetAtt SqlFSxInstance1.PrivateIp
  Postdeployment:
    Value: https://fwd.aws/5XG6A
    Description: See the deployment guide for post-deployment steps.
